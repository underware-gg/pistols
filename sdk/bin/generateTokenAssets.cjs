#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { Buffer } = require("node:buffer");

function getFolderFilesRecursively(folder, extensions = [], includeSubfolders = false) {
  let files = [];
  fs.readdirSync(folder).forEach(File => {
    const absPath = path.join(folder, File);
    if (fs.statSync(absPath).isDirectory()) {
      if (includeSubfolders) {
        files = files.concat(getFolderFilesRecursively(absPath, extensions, includeSubfolders));
      }
    } else if (
      extensions.length === 0 ||
      extensions.some(ext => absPath.endsWith(ext))
    ) {
      files.push(absPath);
    }
  });
  return files.sort((a, b) => a.localeCompare(b));
}

function cleanLine(line) {
  const parts = line.split('//');
  const contents = parts[0].trim();
  const comment = parts[1]?.trim();
  return {
    contents,
    comment,
  };
}

//----------------------
// Execution
//
console.log("executing [generateTokenAssets.cjs]...", process.argv)

const sources = [
  {
    source_path: '../../client/public/profiles',
    out_file: '../src/games/pistols/tokens/assets/profiles.tsx',
    include_subfolders: true,
  },
  {
    source_path: '../../client/public/textures/cards',
    out_file: '../src/games/pistols/tokens/assets/cards.tsx',
    include_subfolders: false,
  },
  {
    source_path: '../../client/public/images/ui',
    out_file: '../src/games/pistols/tokens/assets/ui.tsx',
    include_subfolders: false,
  },
];

sources.forEach(source => {
  const srcPath = path.resolve(__dirname, source.source_path);
  const outPath = path.resolve(__dirname, source.out_file);
  const encodedPath = outPath.slice(0, outPath.lastIndexOf("/")) + '/encoded';
  // console.log(`SRC PATH:`, srcPath);
  // console.log(`OUT PATH:`, outPath);
  // console.log(`ENCODED PATH:`, encodedPath);

  let assetsNames = [];

  let files = getFolderFilesRecursively(srcPath, ['.png', '.jpg'], source.include_subfolders);
  files.forEach(async filePath => {
    const fileContents = fs.readFileSync(filePath);
    let ix = filePath.indexOf('/public/') + '/public'.length;
    let name = filePath.slice(ix).replaceAll('/', '_').replaceAll('.', '_');
    // console.log(`FILE:`, filePath, name);
    const encoded = Buffer.from(fileContents).toString('base64');
    assetsNames.push(name);
    //
    // create encoded asset file
    let assetFileContents = '';
    assetFileContents += `/* Autogenerated file. Do not edit manually. */\n`;
    assetFileContents += `// encoded from: ${filePath}\n`;
    assetFileContents += `\n`;
    assetFileContents += `const ${name} = "${encoded}";\n`;
    assetFileContents += `\n`;
    assetFileContents += `export default ${name};\n`;
    // save asset file
    const assetFilePath = path.resolve(__dirname, encodedPath + `/${name}.tsx`);
    fs.writeFileSync(assetFilePath, assetFileContents);
  })
  

  // build file contents
  let fileContents = '';
  fileContents += `/* Autogenerated file. Do not edit manually. */\n`;
  fileContents += `// from: ${source.source_path}\n`;
  fileContents += `\n`;
  assetsNames.forEach(name => {
    fileContents += `import ${name} from "./encoded/${name}"\n`;
  });
  fileContents += `\n`;
  fileContents += `export const assets = {\n`;
  assetsNames.forEach(name => {
    fileContents += `  ${name}: ${name},\n`;
  });
  fileContents += `}\n`;
  
  // save file
  fs.writeFile(outPath, fileContents, (err) => {
    if (err) {
      console.error("ERROR: error writing file:", err);
    } else {
      console.log("Token assets file generated:", outPath);
    }
  });
})


