// Generated by dojo-bindgen on Wed, 30 Oct 2024 18:57:28 +0000. Do not modify this file manually.
import { Account } from "starknet";
import {
    Clause,
    Client,
    ModelClause,
    createClient,
    valueToToriiValueAndOperator,
} from "@dojoengine/torii-client";
import {
    LOCAL_KATANA,
    LOCAL_RELAY,
    LOCAL_TORII,
    createManifestFromJson,
} from "@dojoengine/core";

// Type definition for `core::byte_array::ByteArray` struct
export interface ByteArray {
    data: string[];
    pending_word: string;
    pending_word_len: number;
}

// Type definition for `pistols::models::duelist::Scoreboard` struct
export interface Scoreboard {
    table_id: string;
    duelist_id: bigint;
    score: Score;
}

// Type definition for `pistols::models::duelist::Score` struct
export interface Score {
    honour: number;
    total_duels: number;
    total_wins: number;
    total_losses: number;
    total_draws: number;
    honour_history: bigint;
}

// Type definition for `dojo::model::layout::FieldLayout` struct
export interface FieldLayout {
    selector: string;
    layout: Layout;
}

// Type definition for `dojo::model::layout::Layout` enum
type Layout = { type: 'Fixed'; data: number[]; } | { type: 'Struct'; data: FieldLayout[]; } | { type: 'Tuple'; data: Layout[]; } | { type: 'Array'; data: Layout[]; } | { type: 'ByteArray'; } | { type: 'Enum'; data: FieldLayout[]; }
// Type definition for `core::option::Option::<core::integer::u32>` enum
type Option<A> = { type: 'Some'; data: A; } | { type: 'None'; }

// Type definition for `pistols::models::table::TableAdmittance` struct
export interface TableAdmittance {
    table_id: string;
    accounts: string[];
    duelists: bigint[];
}


// Type definition for `pistols::models::challenge::Moves` struct
export interface Moves {
    salt: string;
    hashed: bigint;
    card_1: number;
    card_2: number;
    card_3: number;
    card_4: number;
}

// Type definition for `pistols::models::challenge::DuelistState` struct
export interface DuelistState {
    chances: number;
    damage: number;
    health: number;
    dice_fire: number;
    honour: number;
}

// Type definition for `pistols::models::challenge::Round` struct
export interface Round {
    duel_id: bigint;
    moves_a: Moves;
    moves_b: Moves;
    state_a: DuelistState;
    state_b: DuelistState;
    state: RoundState;
    final_blow: string;
}

// Type definition for `pistols::types::round_state::RoundState` enum
type RoundState = { type: 'Null'; } | { type: 'Commit'; } | { type: 'Reveal'; } | { type: 'Finished'; }

// Type definition for `pistols::models::duelist::Duelist` struct
export interface Duelist {
    duelist_id: bigint;
    name: string;
    profile_pic_type: ProfilePicType;
    profile_pic_uri: string;
    timestamp: bigint;
    score: Score;
}

// Type definition for `pistols::models::duelist::ProfilePicType` enum
type ProfilePicType = { type: 'Undefined'; } | { type: 'Duelist'; } | { type: 'External'; }

// Type definition for `pistols::models::duelist::Pact` struct
export interface Pact {
    table_id: string;
    pair: bigint;
    duel_id: bigint;
}


// Type definition for `pistols::models::table::TableConfig` struct
export interface TableConfig {
    table_id: string;
    description: string;
    table_type: TableType;
    deck_type: DeckType;
    fee_collector_address: string;
    fee_min: bigint;
    is_open: boolean;
}

// Type definition for `pistols::models::table::TableType` enum
type TableType = { type: 'Undefined'; } | { type: 'Classic'; } | { type: 'Tournament'; } | { type: 'IRLTournament'; }
// Type definition for `pistols::types::cards::hand::DeckType` enum
type DeckType = { type: 'None'; } | { type: 'Classic'; }

// Type definition for `pistols::systems::components::token_bound::TokenBoundAddress` struct
export interface TokenBoundAddress {
    recipient: string;
    contract_address: string;
    token_id: bigint;
}


// Type definition for `pistols::models::config::TokenConfig` struct
export interface TokenConfig {
    token_address: string;
    minter_address: string;
    renderer_address: string;
    minted_count: bigint;
}


// Type definition for `pistols::models::challenge::Challenge` struct
export interface Challenge {
    duel_id: bigint;
    seed: bigint;
    table_id: string;
    premise: Premise;
    quote: string;
    address_a: string;
    address_b: string;
    duelist_id_a: bigint;
    duelist_id_b: bigint;
    state: ChallengeState;
    winner: number;
    timestamp_start: bigint;
    timestamp_end: bigint;
}

// Type definition for `pistols::types::challenge_state::ChallengeState` enum
type ChallengeState = { type: 'Null'; } | { type: 'Awaiting'; } | { type: 'Withdrawn'; } | { type: 'Refused'; } | { type: 'Expired'; } | { type: 'InProgress'; } | { type: 'Resolved'; } | { type: 'Draw'; }
// Type definition for `pistols::types::premise::Premise` enum
type Premise = { type: 'Null'; } | { type: 'Matter'; } | { type: 'Debt'; } | { type: 'Dispute'; } | { type: 'Honour'; } | { type: 'Hatred'; } | { type: 'Blood'; } | { type: 'Nothing'; } | { type: 'Tournament'; }

// Type definition for `core::integer::u256` struct
export interface U256 {
    low: bigint;
    high: bigint;
}

// Type definition for `pistols::models::payment::Payment` struct
export interface Payment {
    key: string;
    amount: U256;
    client_percent: number;
    ranking_percent: number;
    owner_percent: number;
    pool_percent: number;
    treasury_percent: number;
}


// Type definition for `pistols::models::config::CoinConfig` struct
export interface CoinConfig {
    coin_address: string;
    minter_address: string;
    faucet_amount: bigint;
}


// Type definition for `pistols::models::config::Config` struct
export interface Config {
    key: number;
    treasury_address: string;
    lords_address: string;
    is_paused: boolean;
}


class BaseCalls {
    contractAddress: string;
    account?: Account;

    constructor(contractAddress: string, account?: Account) {
        this.account = account;
        this.contractAddress = contractAddress;
    }

    async execute(entrypoint: string, calldata: any[] = []): Promise<void> {
        if (!this.account) {
            throw new Error("No account set to interact with dojo_starter");
        }

        await this.account.execute(
            {
                contractAddress: this.contractAddress,
                entrypoint,
                calldata,
            },
            undefined,
            {
                maxFee: 0,
            }
        );
    }
}

class AdminCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(treasury_address: string, lords_address: string): Promise<void> {
        try {
            await this.execute("dojo_init", [treasury_address,
                lords_address])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async amIAdmin(account_address: string): Promise<void> {
        try {
            await this.execute("am_i_admin", [account_address])
        } catch (error) {
            console.error("Error executing amIAdmin:", error);
            throw error;
        }
    }

    async grantAdmin(account_address: string, granted: boolean): Promise<void> {
        try {
            await this.execute("grant_admin", [account_address,
                granted])
        } catch (error) {
            console.error("Error executing grantAdmin:", error);
            throw error;
        }
    }

    async setConfig(config: Config): Promise<void> {
        try {
            await this.execute("set_config", [props.config.key,
                    props.config.treasury_address,
                    props.config.lords_address,
                    props.config.is_paused])
        } catch (error) {
            console.error("Error executing setConfig:", error);
            throw error;
        }
    }

    async setPaused(paused: boolean): Promise<void> {
        try {
            await this.execute("set_paused", [paused])
        } catch (error) {
            console.error("Error executing setPaused:", error);
            throw error;
        }
    }

    async openTable(table_id: string, is_open: boolean): Promise<void> {
        try {
            await this.execute("open_table", [table_id,
                is_open])
        } catch (error) {
            console.error("Error executing openTable:", error);
            throw error;
        }
    }

    async setTable(table: TableConfig): Promise<void> {
        try {
            await this.execute("set_table", [props.table.table_id,
                    props.table.description,
                    props.table.table_type,
                    props.table.deck_type,
                    props.table.fee_collector_address,
                    props.table.fee_min,
                    props.table.is_open])
        } catch (error) {
            console.error("Error executing setTable:", error);
            throw error;
        }
    }

    async setTableAdmittance(table_admittance: TableAdmittance): Promise<void> {
        try {
            await this.execute("set_table_admittance", [props.table_admittance.table_id,
                    props.table_admittance.accounts,
                    props.table_admittance.duelists])
        } catch (error) {
            console.error("Error executing setTableAdmittance:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }
}
class GameCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async commitMoves(duelist_id: bigint, duel_id: bigint, hashed: bigint): Promise<void> {
        try {
            await this.execute("commit_moves", [duelist_id,
                duel_id,
                hashed])
        } catch (error) {
            console.error("Error executing commitMoves:", error);
            throw error;
        }
    }

    async revealMoves(duelist_id: bigint, duel_id: bigint, salt: string, moves: number[]): Promise<void> {
        try {
            await this.execute("reveal_moves", [duelist_id,
                duel_id,
                salt,
                moves])
        } catch (error) {
            console.error("Error executing revealMoves:", error);
            throw error;
        }
    }

    async getPlayerCardDecks(table_id: string): Promise<void> {
        try {
            await this.execute("get_player_card_decks", [table_id])
        } catch (error) {
            console.error("Error executing getPlayerCardDecks:", error);
            throw error;
        }
    }

    async getDuelProgress(duel_id: bigint): Promise<void> {
        try {
            await this.execute("get_duel_progress", [duel_id])
        } catch (error) {
            console.error("Error executing getDuelProgress:", error);
            throw error;
        }
    }

    async testValidateCommitMessage(account: string, signature: string[], duelId: string, duelistId: string): Promise<void> {
        try {
            await this.execute("test_validate_commit_message", [account,
                signature,
                duelId,
                duelistId])
        } catch (error) {
            console.error("Error executing testValidateCommitMessage:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }
}
class BankCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async charge(payer: string, payment: Payment): Promise<void> {
        try {
            await this.execute("charge", [payer,
                props.payment.key,
                    props.payment.amount,
                    props.payment.client_percent,
                    props.payment.ranking_percent,
                    props.payment.owner_percent,
                    props.payment.pool_percent,
                    props.payment.treasury_percent])
        } catch (error) {
            console.error("Error executing charge:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }
}
class RngCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async reseed(seed: string, salt: string): Promise<void> {
        try {
            await this.execute("reseed", [seed,
                salt])
        } catch (error) {
            console.error("Error executing reseed:", error);
            throw error;
        }
    }

    async newShuffler(shuffle_size: number): Promise<void> {
        try {
            await this.execute("new_shuffler", [shuffle_size])
        } catch (error) {
            console.error("Error executing newShuffler:", error);
            throw error;
        }
    }
}
class DuelistTokenCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async canMint(caller_address: string): Promise<void> {
        try {
            await this.execute("can_mint", [caller_address])
        } catch (error) {
            console.error("Error executing canMint:", error);
            throw error;
        }
    }

    async exists(token_id: bigint): Promise<void> {
        try {
            await this.execute("exists", [token_id])
        } catch (error) {
            console.error("Error executing exists:", error);
            throw error;
        }
    }

    async isOwnerOf(address: string, token_id: bigint): Promise<void> {
        try {
            await this.execute("is_owner_of", [address,
                token_id])
        } catch (error) {
            console.error("Error executing isOwnerOf:", error);
            throw error;
        }
    }

    async getTokenName(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_name", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenName:", error);
            throw error;
        }
    }

    async getTokenDescription(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_description", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenDescription:", error);
            throw error;
        }
    }

    async getTokenImage(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_image", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenImage:", error);
            throw error;
        }
    }

    async getAttributePairs(token_id: U256): Promise<void> {
        try {
            await this.execute("get_attribute_pairs", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getAttributePairs:", error);
            throw error;
        }
    }

    async getMetadataPairs(token_id: U256): Promise<void> {
        try {
            await this.execute("get_metadata_pairs", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getMetadataPairs:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(token_id: U256): Promise<void> {
        try {
            await this.execute("owner_of", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                props.token_id.low,
                    props.token_id.high,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [from,
                to,
                props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("approve", [to,
                props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(token_id: U256): Promise<void> {
        try {
            await this.execute("get_approved", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async tokenUri(token_id: U256): Promise<void> {
        try {
            await this.execute("token_uri", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(tokenId: U256): Promise<void> {
        try {
            await this.execute("ownerOf", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                props.tokenId.low,
                    props.tokenId.high,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [from,
                to,
                props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(tokenId: U256): Promise<void> {
        try {
            await this.execute("getApproved", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async tokenUri(tokenId: U256): Promise<void> {
        try {
            await this.execute("tokenURI", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async calcFee(recipient: string): Promise<void> {
        try {
            await this.execute("calc_fee", [recipient])
        } catch (error) {
            console.error("Error executing calcFee:", error);
            throw error;
        }
    }

    async createDuelist(recipient: string, name: string, profile_pic_type: ProfilePicType, profile_pic_uri: string): Promise<void> {
        try {
            await this.execute("create_duelist", [recipient,
                name,
                profile_pic_type,
                profile_pic_uri])
        } catch (error) {
            console.error("Error executing createDuelist:", error);
            throw error;
        }
    }

    async updateDuelist(duelist_id: bigint, name: string, profile_pic_type: ProfilePicType, profile_pic_uri: string): Promise<void> {
        try {
            await this.execute("update_duelist", [duelist_id,
                name,
                profile_pic_type,
                profile_pic_uri])
        } catch (error) {
            console.error("Error executing updateDuelist:", error);
            throw error;
        }
    }

    async deleteDuelist(duelist_id: bigint): Promise<void> {
        try {
            await this.execute("delete_duelist", [duelist_id])
        } catch (error) {
            console.error("Error executing deleteDuelist:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(base_uri: string, minter_address: string, renderer_address: string, fee_amount: bigint): Promise<void> {
        try {
            await this.execute("dojo_init", [base_uri,
                minter_address,
                renderer_address,
                fee_amount])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }
}
class FameCoinCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async addressOfToken(contract_address: string, token_id: bigint): Promise<void> {
        try {
            await this.execute("address_of_token", [contract_address,
                token_id])
        } catch (error) {
            console.error("Error executing addressOfToken:", error);
            throw error;
        }
    }

    async tokenOfAddress(address: string): Promise<void> {
        try {
            await this.execute("token_of_address", [address])
        } catch (error) {
            console.error("Error executing tokenOfAddress:", error);
            throw error;
        }
    }

    async balanceOfToken(contract_address: string, token_id: bigint): Promise<void> {
        try {
            await this.execute("balance_of_token", [contract_address,
                token_id])
        } catch (error) {
            console.error("Error executing balanceOfToken:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async mintedDuelist(duelist_id: bigint, amount_paid: U256): Promise<void> {
        try {
            await this.execute("minted_duelist", [duelist_id,
                props.amount_paid.low,
                    props.amount_paid.high])
        } catch (error) {
            console.error("Error executing mintedDuelist:", error);
            throw error;
        }
    }

    async updatedDuelist(from: string, to: string, duelist_id: bigint): Promise<void> {
        try {
            await this.execute("updated_duelist", [from,
                to,
                duelist_id])
        } catch (error) {
            console.error("Error executing updatedDuelist:", error);
            throw error;
        }
    }

    async dojoInit(duelist_contract_address: string): Promise<void> {
        try {
            await this.execute("dojo_init", [duelist_contract_address])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("total_supply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async allowance(owner: string, spender: string): Promise<void> {
        try {
            await this.execute("allowance", [owner,
                spender])
        } catch (error) {
            console.error("Error executing allowance:", error);
            throw error;
        }
    }

    async transfer(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer", [recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transfer:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(spender: string, amount: U256): Promise<void> {
        try {
            await this.execute("approve", [spender,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async decimals(): Promise<void> {
        try {
            await this.execute("decimals", [])
        } catch (error) {
            console.error("Error executing decimals:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("totalSupply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }
}
class LordsMockCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("total_supply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async allowance(owner: string, spender: string): Promise<void> {
        try {
            await this.execute("allowance", [owner,
                spender])
        } catch (error) {
            console.error("Error executing allowance:", error);
            throw error;
        }
    }

    async transfer(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer", [recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transfer:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(spender: string, amount: U256): Promise<void> {
        try {
            await this.execute("approve", [spender,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async decimals(): Promise<void> {
        try {
            await this.execute("decimals", [])
        } catch (error) {
            console.error("Error executing decimals:", error);
            throw error;
        }
    }

    async totalSupply(): Promise<void> {
        try {
            await this.execute("totalSupply", [])
        } catch (error) {
            console.error("Error executing totalSupply:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async transferFrom(sender: string, recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [sender,
                recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(game_contract_address: string, faucet_amount: bigint): Promise<void> {
        try {
            await this.execute("dojo_init", [game_contract_address,
                faucet_amount])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async faucet(): Promise<void> {
        try {
            await this.execute("faucet", [])
        } catch (error) {
            console.error("Error executing faucet:", error);
            throw error;
        }
    }

    async mint(recipient: string, amount: U256): Promise<void> {
        try {
            await this.execute("mint", [recipient,
                props.amount.low,
                    props.amount.high])
        } catch (error) {
            console.error("Error executing mint:", error);
            throw error;
        }
    }
}
class DuelTokenCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async dojoInit(base_uri: string, minter_address: string, renderer_address: string, fee_amount: bigint): Promise<void> {
        try {
            await this.execute("dojo_init", [base_uri,
                minter_address,
                renderer_address,
                fee_amount])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async canMint(caller_address: string): Promise<void> {
        try {
            await this.execute("can_mint", [caller_address])
        } catch (error) {
            console.error("Error executing canMint:", error);
            throw error;
        }
    }

    async exists(token_id: bigint): Promise<void> {
        try {
            await this.execute("exists", [token_id])
        } catch (error) {
            console.error("Error executing exists:", error);
            throw error;
        }
    }

    async isOwnerOf(address: string, token_id: bigint): Promise<void> {
        try {
            await this.execute("is_owner_of", [address,
                token_id])
        } catch (error) {
            console.error("Error executing isOwnerOf:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async createDuel(duelist_id: bigint, challenged_id_or_address: string, premise: Premise, quote: string, table_id: string, expire_hours: bigint): Promise<void> {
        try {
            await this.execute("create_duel", [duelist_id,
                challenged_id_or_address,
                premise,
                quote,
                table_id,
                expire_hours])
        } catch (error) {
            console.error("Error executing createDuel:", error);
            throw error;
        }
    }

    async replyDuel(duelist_id: bigint, duel_id: bigint, accepted: boolean): Promise<void> {
        try {
            await this.execute("reply_duel", [duelist_id,
                duel_id,
                accepted])
        } catch (error) {
            console.error("Error executing replyDuel:", error);
            throw error;
        }
    }

    async deleteDuel(duel_id: bigint): Promise<void> {
        try {
            await this.execute("delete_duel", [duel_id])
        } catch (error) {
            console.error("Error executing deleteDuel:", error);
            throw error;
        }
    }

    async calcFee(table_id: string): Promise<void> {
        try {
            await this.execute("calc_fee", [table_id])
        } catch (error) {
            console.error("Error executing calcFee:", error);
            throw error;
        }
    }

    async getPact(table_id: string, duelist_id_a: bigint, duelist_id_b: bigint): Promise<void> {
        try {
            await this.execute("get_pact", [table_id,
                duelist_id_a,
                duelist_id_b])
        } catch (error) {
            console.error("Error executing getPact:", error);
            throw error;
        }
    }

    async hasPact(table_id: string, duelist_id_a: bigint, duelist_id_b: bigint): Promise<void> {
        try {
            await this.execute("has_pact", [table_id,
                duelist_id_a,
                duelist_id_b])
        } catch (error) {
            console.error("Error executing hasPact:", error);
            throw error;
        }
    }

    async canJoin(table_id: string, duelist_id: bigint): Promise<void> {
        try {
            await this.execute("can_join", [table_id,
                duelist_id])
        } catch (error) {
            console.error("Error executing canJoin:", error);
            throw error;
        }
    }

    async getTokenName(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_name", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenName:", error);
            throw error;
        }
    }

    async getTokenDescription(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_description", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenDescription:", error);
            throw error;
        }
    }

    async getTokenImage(token_id: U256): Promise<void> {
        try {
            await this.execute("get_token_image", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getTokenImage:", error);
            throw error;
        }
    }

    async getAttributePairs(token_id: U256): Promise<void> {
        try {
            await this.execute("get_attribute_pairs", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getAttributePairs:", error);
            throw error;
        }
    }

    async getMetadataPairs(token_id: U256): Promise<void> {
        try {
            await this.execute("get_metadata_pairs", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getMetadataPairs:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(token_id: U256): Promise<void> {
        try {
            await this.execute("owner_of", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                props.token_id.low,
                    props.token_id.high,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [from,
                to,
                props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("approve", [to,
                props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(token_id: U256): Promise<void> {
        try {
            await this.execute("get_approved", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async tokenUri(token_id: U256): Promise<void> {
        try {
            await this.execute("token_uri", [props.token_id.low,
                    props.token_id.high])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(tokenId: U256): Promise<void> {
        try {
            await this.execute("ownerOf", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                props.tokenId.low,
                    props.tokenId.high,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [from,
                to,
                props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(tokenId: U256): Promise<void> {
        try {
            await this.execute("getApproved", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async tokenUri(tokenId: U256): Promise<void> {
        try {
            await this.execute("tokenURI", [props.tokenId.low,
                    props.tokenId.high])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }
}

type Query = Partial<{
    Scoreboard: ModelClause<Scoreboard>;
    TableAdmittance: ModelClause<TableAdmittance>;
    Round: ModelClause<Round>;
    Duelist: ModelClause<Duelist>;
    Pact: ModelClause<Pact>;
    TableConfig: ModelClause<TableConfig>;
    TokenBoundAddress: ModelClause<TokenBoundAddress>;
    TokenConfig: ModelClause<TokenConfig>;
    Challenge: ModelClause<Challenge>;
    Payment: ModelClause<Payment>;
    CoinConfig: ModelClause<CoinConfig>;
    Config: ModelClause<Config>;
}>;

type ResultMapping = {
    Scoreboard: Scoreboard;
    TableAdmittance: TableAdmittance;
    Round: Round;
    Duelist: Duelist;
    Pact: Pact;
    TableConfig: TableConfig;
    TokenBoundAddress: TokenBoundAddress;
    TokenConfig: TokenConfig;
    Challenge: Challenge;
    Payment: Payment;
    CoinConfig: CoinConfig;
    Config: Config;
};

type QueryResult<T extends Query> = {
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
};

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model,
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}
type GeneralParams = {
    toriiUrl?: string;
    relayUrl?: string;
    account?: Account;
};

type InitialParams = GeneralParams &
    (
        | {
                rpcUrl?: string;
                worldAddress: string;
                adminAddress: string;
    gameAddress: string;
    bankAddress: string;
    rngAddress: string;
    duelistTokenAddress: string;
    fameCoinAddress: string;
    lordsMockAddress: string;
    duelTokenAddress: string;
            }
        | {
                manifest: any;
            }
    );

export class Pistols {
    rpcUrl: string;
    toriiUrl: string;
    toriiPromise: Promise<Client>;
    relayUrl: string;
    worldAddress: string;
    private _account?: Account;
    admin: AdminCalls;
    adminAddress: string;
    game: GameCalls;
    gameAddress: string;
    bank: BankCalls;
    bankAddress: string;
    rng: RngCalls;
    rngAddress: string;
    duelistToken: DuelistTokenCalls;
    duelistTokenAddress: string;
    fameCoin: FameCoinCalls;
    fameCoinAddress: string;
    lordsMock: LordsMockCalls;
    lordsMockAddress: string;
    duelToken: DuelTokenCalls;
    duelTokenAddress: string;

    constructor(params: InitialParams) {
        if ("manifest" in params) {
            const config = createManifestFromJson(params.manifest);
            this.rpcUrl = config.world.metadata.rpc_url;
            this.worldAddress = config.world.address;

            const adminAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::admin::admin"
            )?.address;

            if (!adminAddress) {
                throw new Error("No admin contract found in the manifest");
            }

            this.adminAddress = adminAddress;
    const gameAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::game::game"
            )?.address;

            if (!gameAddress) {
                throw new Error("No game contract found in the manifest");
            }

            this.gameAddress = gameAddress;
    const bankAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::bank::bank"
            )?.address;

            if (!bankAddress) {
                throw new Error("No bank contract found in the manifest");
            }

            this.bankAddress = bankAddress;
    const rngAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::rng::rng"
            )?.address;

            if (!rngAddress) {
                throw new Error("No rng contract found in the manifest");
            }

            this.rngAddress = rngAddress;
    const duelistTokenAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::duelistToken::duelistToken"
            )?.address;

            if (!duelistTokenAddress) {
                throw new Error("No duelistToken contract found in the manifest");
            }

            this.duelistTokenAddress = duelistTokenAddress;
    const fameCoinAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::fameCoin::fameCoin"
            )?.address;

            if (!fameCoinAddress) {
                throw new Error("No fameCoin contract found in the manifest");
            }

            this.fameCoinAddress = fameCoinAddress;
    const lordsMockAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::lordsMock::lordsMock"
            )?.address;

            if (!lordsMockAddress) {
                throw new Error("No lordsMock contract found in the manifest");
            }

            this.lordsMockAddress = lordsMockAddress;
    const duelTokenAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::duelToken::duelToken"
            )?.address;

            if (!duelTokenAddress) {
                throw new Error("No duelToken contract found in the manifest");
            }

            this.duelTokenAddress = duelTokenAddress;
        } else {
            this.rpcUrl = params.rpcUrl || LOCAL_KATANA;
            this.worldAddress = params.worldAddress;
            this.adminAddress = params.adminAddress;
    this.gameAddress = params.gameAddress;
    this.bankAddress = params.bankAddress;
    this.rngAddress = params.rngAddress;
    this.duelistTokenAddress = params.duelistTokenAddress;
    this.fameCoinAddress = params.fameCoinAddress;
    this.lordsMockAddress = params.lordsMockAddress;
    this.duelTokenAddress = params.duelTokenAddress;
        }
        this.toriiUrl = params.toriiUrl || LOCAL_TORII;
        this.relayUrl = params.relayUrl || LOCAL_RELAY;
        this._account = params.account;
        this.admin = new AdminCalls(this.adminAddress, this._account);
    this.game = new GameCalls(this.gameAddress, this._account);
    this.bank = new BankCalls(this.bankAddress, this._account);
    this.rng = new RngCalls(this.rngAddress, this._account);
    this.duelistToken = new DuelistTokenCalls(this.duelistTokenAddress, this._account);
    this.fameCoin = new FameCoinCalls(this.fameCoinAddress, this._account);
    this.lordsMock = new LordsMockCalls(this.lordsMockAddress, this._account);
    this.duelToken = new DuelTokenCalls(this.duelTokenAddress, this._account);

        this.toriiPromise = createClient([], {
            rpcUrl: this.rpcUrl,
            toriiUrl: this.toriiUrl,
            worldAddress: this.worldAddress,
            relayUrl: this.relayUrl,
        });
    }

    get account(): Account | undefined {
        return this._account;
    }

    set account(account: Account) {
        this._account = account;
        this.admin = new AdminCalls(this.adminAddress, this._account);
    this.game = new GameCalls(this.gameAddress, this._account);
    this.bank = new BankCalls(this.bankAddress, this._account);
    this.rng = new RngCalls(this.rngAddress, this._account);
    this.duelistToken = new DuelistTokenCalls(this.duelistTokenAddress, this._account);
    this.fameCoin = new FameCoinCalls(this.fameCoinAddress, this._account);
    this.lordsMock = new LordsMockCalls(this.lordsMockAddress, this._account);
    this.duelToken = new DuelTokenCalls(this.duelTokenAddress, this._account);
    }

    async query<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        return {
            torii,
            findEntities: async () => this.findEntities(query, limit, offset),
        };
    }

    async findEntities<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        const clause = convertQueryToToriiClause(query);

        const toriiResult = await torii.getEntities({
            limit,
            offset,
            clause,
        });

        return toriiResult as Record<string, QueryResult<T>>;
    }

    async findEntity<T extends Query>(query: T) {
        const result = await this.findEntities(query, 1);

        if (Object.values(result).length === 0) {
            return undefined;
        }

        return Object.values(result)[0] as QueryResult<T>;
    }
}