
// Generated by dojo-bindgen on Wed, 31 Jul 2024 02:09:32 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    // System definitions for `pistols-minter` contract
    function minter() {
        const contract_name = "minter";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "world",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `mint` system with the specified Account and calldata
        const mint = async (props: { account: Account, to: bigint, token_contract_address: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "mint",
                    [props.to,
                props.token_contract_address],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `can_mint` system with the specified Account and calldata
        const can_mint = async (props: { account: Account, to: bigint, token_contract_address: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "can_mint",
                    [props.to,
                props.token_contract_address],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_open` system with the specified Account and calldata
        const set_open = async (props: { account: Account, token_contract_address: bigint, is_open: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_open",
                    [props.token_contract_address,
                props.is_open],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, mint, can_mint, set_open
        };
    }

    // System definitions for `pistols-token_duelist` contract
    function token_duelist() {
        const contract_name = "token_duelist";

        
        // Call the `get_approved` system with the specified Account and calldata
        const get_approved = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_approved",
                    [props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `is_approved_for_all` system with the specified Account and calldata
        const is_approved_for_all = async (props: { account: Account, owner: bigint, operator: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "is_approved_for_all",
                    [props.owner,
                props.operator],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `approve` system with the specified Account and calldata
        const approve = async (props: { account: Account, to: bigint, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "approve",
                    [props.to,
                props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_approval_for_all` system with the specified Account and calldata
        const set_approval_for_all = async (props: { account: Account, operator: bigint, approved: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_approval_for_all",
                    [props.operator,
                props.approved],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `tokenURI` system with the specified Account and calldata
        const tokenURI = async (props: { account: Account, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "tokenURI",
                    [props.tokenId.low,
                    props.tokenId.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `total_supply` system with the specified Account and calldata
        const total_supply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "total_supply",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `token_by_index` system with the specified Account and calldata
        const token_by_index = async (props: { account: Account, index: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "token_by_index",
                    [props.index.low,
                    props.index.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `token_of_owner_by_index` system with the specified Account and calldata
        const token_of_owner_by_index = async (props: { account: Account, owner: bigint, index: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "token_of_owner_by_index",
                    [props.owner,
                props.index.low,
                    props.index.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `getApproved` system with the specified Account and calldata
        const getApproved = async (props: { account: Account, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "getApproved",
                    [props.tokenId.low,
                    props.tokenId.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `isApprovedForAll` system with the specified Account and calldata
        const isApprovedForAll = async (props: { account: Account, owner: bigint, operator: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "isApprovedForAll",
                    [props.owner,
                props.operator],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setApprovalForAll` system with the specified Account and calldata
        const setApprovalForAll = async (props: { account: Account, operator: bigint, approved: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "setApprovalForAll",
                    [props.operator,
                props.approved],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `supportsInterface` system with the specified Account and calldata
        const supportsInterface = async (props: { account: Account, interfaceId: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "supportsInterface",
                    [props.interfaceId],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "world",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `mint` system with the specified Account and calldata
        const mint = async (props: { account: Account, to: bigint, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "mint",
                    [props.to,
                props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `burn` system with the specified Account and calldata
        const burn = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "burn",
                    [props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `build_uri` system with the specified Account and calldata
        const build_uri = async (props: { account: Account, token_id: models.U256, encode: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "build_uri",
                    [props.token_id.low,
                    props.token_id.high,
                props.encode],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `balanceOf` system with the specified Account and calldata
        const balanceOf = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balanceOf",
                    [props.account],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transferFrom` system with the specified Account and calldata
        const transferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transferFrom",
                    [props.from,
                props.to,
                props.tokenId.low,
                    props.tokenId.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `safeTransferFrom` system with the specified Account and calldata
        const safeTransferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256, data: RecsType.BigIntArray }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "safeTransferFrom",
                    [props.from,
                props.to,
                props.tokenId.low,
                    props.tokenId.high,
                ...props.data],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `supports_interface` system with the specified Account and calldata
        const supports_interface = async (props: { account: Account, interface_id: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "supports_interface",
                    [props.interface_id],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `owner_of` system with the specified Account and calldata
        const owner_of = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "owner_of",
                    [props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `totalSupply` system with the specified Account and calldata
        const totalSupply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "totalSupply",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `tokenByIndex` system with the specified Account and calldata
        const tokenByIndex = async (props: { account: Account, index: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "tokenByIndex",
                    [props.index.low,
                    props.index.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `tokenOfOwnerByIndex` system with the specified Account and calldata
        const tokenOfOwnerByIndex = async (props: { account: Account, owner: bigint, index: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "tokenOfOwnerByIndex",
                    [props.owner,
                props.index.low,
                    props.index.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `name` system with the specified Account and calldata
        const name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "name",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `symbol` system with the specified Account and calldata
        const symbol = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "symbol",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `token_uri` system with the specified Account and calldata
        const token_uri = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "token_uri",
                    [props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `balance_of` system with the specified Account and calldata
        const balance_of = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balance_of",
                    [props.account],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer_from` system with the specified Account and calldata
        const transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transfer_from",
                    [props.from,
                props.to,
                props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `safe_transfer_from` system with the specified Account and calldata
        const safe_transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256, data: RecsType.BigIntArray }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "safe_transfer_from",
                    [props.from,
                props.to,
                props.token_id.low,
                    props.token_id.high,
                ...props.data],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `ownerOf` system with the specified Account and calldata
        const ownerOf = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "ownerOf",
                    [props.token_id.low,
                    props.token_id.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            get_approved, is_approved_for_all, approve, set_approval_for_all, tokenURI, total_supply, token_by_index, token_of_owner_by_index, getApproved, isApprovedForAll, setApprovalForAll, supportsInterface, world, mint, burn, build_uri, balanceOf, transferFrom, safeTransferFrom, supports_interface, owner_of, totalSupply, tokenByIndex, tokenOfOwnerByIndex, name, symbol, token_uri, balance_of, transfer_from, safe_transfer_from, ownerOf
        };
    }

    // System definitions for `pistols-lords_mock` contract
    function lords_mock() {
        const contract_name = "lords_mock";

        
        // Call the `faucet` system with the specified Account and calldata
        const faucet = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "faucet",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `mint` system with the specified Account and calldata
        const mint = async (props: { account: Account, to: bigint, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "mint",
                    [props.to,
                props.amount.low,
                    props.amount.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `balance_of` system with the specified Account and calldata
        const balance_of = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balance_of",
                    [props.account],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer` system with the specified Account and calldata
        const transfer = async (props: { account: Account, recipient: bigint, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transfer",
                    [props.recipient,
                props.amount.low,
                    props.amount.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer_from` system with the specified Account and calldata
        const transfer_from = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transfer_from",
                    [props.sender,
                props.recipient,
                props.amount.low,
                    props.amount.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `allowance` system with the specified Account and calldata
        const allowance = async (props: { account: Account, owner: bigint, spender: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "allowance",
                    [props.owner,
                props.spender],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `approve` system with the specified Account and calldata
        const approve = async (props: { account: Account, spender: bigint, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "approve",
                    [props.spender,
                props.amount.low,
                    props.amount.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `name` system with the specified Account and calldata
        const name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "name",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `symbol` system with the specified Account and calldata
        const symbol = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "symbol",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `decimals` system with the specified Account and calldata
        const decimals = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "decimals",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "world",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `totalSupply` system with the specified Account and calldata
        const totalSupply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "totalSupply",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `balanceOf` system with the specified Account and calldata
        const balanceOf = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "balanceOf",
                    [props.account],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `transferFrom` system with the specified Account and calldata
        const transferFrom = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "transferFrom",
                    [props.sender,
                props.recipient,
                props.amount.low,
                    props.amount.high],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `total_supply` system with the specified Account and calldata
        const total_supply = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "total_supply",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            faucet, mint, balance_of, transfer, transfer_from, allowance, approve, name, symbol, decimals, world, totalSupply, balanceOf, transferFrom, total_supply
        };
    }

    // System definitions for `pistols-actions` contract
    function actions() {
        const contract_name = "actions";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "world",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `mint_duelist` system with the specified Account and calldata
        const mint_duelist = async (props: { account: Account, name: bigint, profile_pic_type: models.ProfilePicType, profile_pic_uri: bigint, initial_archetype: models.Archetype }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "mint_duelist",
                    [props.name,
                ["Undefined", "Duelist", "External"].indexOf(props.profile_pic_type.type),
                props.profile_pic_uri,
                props.initial_archetype],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `update_duelist` system with the specified Account and calldata
        const update_duelist = async (props: { account: Account, duelist_id: bigint, name: bigint, profile_pic_type: models.ProfilePicType, profile_pic_uri: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "update_duelist",
                    [props.duelist_id,
                props.name,
                ["Undefined", "Duelist", "External"].indexOf(props.profile_pic_type.type),
                props.profile_pic_uri],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `create_challenge` system with the specified Account and calldata
        const create_challenge = async (props: { account: Account, duelist_id: bigint, challenged_id_or_address: bigint, message: bigint, table_id: bigint, wager_value: bigint, expire_hours: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "create_challenge",
                    [props.duelist_id,
                props.challenged_id_or_address,
                props.message,
                props.table_id,
                props.wager_value,
                props.expire_hours],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `reply_challenge` system with the specified Account and calldata
        const reply_challenge = async (props: { account: Account, duelist_id: bigint, duel_id: bigint, accepted: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "reply_challenge",
                    [props.duelist_id,
                props.duel_id,
                props.accepted],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `commit_action` system with the specified Account and calldata
        const commit_action = async (props: { account: Account, duelist_id: bigint, duel_id: bigint, round_number: number, hash: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "commit_action",
                    [props.duelist_id,
                props.duel_id,
                props.round_number,
                props.hash],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `reveal_action` system with the specified Account and calldata
        const reveal_action = async (props: { account: Account, duelist_id: bigint, duel_id: bigint, round_number: number, salt: number, action_slot1: number, action_slot2: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "reveal_action",
                    [props.duelist_id,
                props.duel_id,
                props.round_number,
                props.salt,
                props.action_slot1,
                props.action_slot2],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_pact` system with the specified Account and calldata
        const get_pact = async (props: { account: Account, table_id: bigint, duelist_id_a: bigint, duelist_id_b: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_pact",
                    [props.table_id,
                props.duelist_id_a,
                props.duelist_id_b],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `has_pact` system with the specified Account and calldata
        const has_pact = async (props: { account: Account, table_id: bigint, duelist_id_a: bigint, duelist_id_b: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "has_pact",
                    [props.table_id,
                props.duelist_id_a,
                props.duelist_id_b],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `can_join` system with the specified Account and calldata
        const can_join = async (props: { account: Account, table_id: bigint, duelist_id: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "can_join",
                    [props.table_id,
                props.duelist_id],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `calc_fee` system with the specified Account and calldata
        const calc_fee = async (props: { account: Account, table_id: bigint, wager_value: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "calc_fee",
                    [props.table_id,
                props.wager_value],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `simulate_chances` system with the specified Account and calldata
        const simulate_chances = async (props: { account: Account, duelist_id: bigint, duel_id: bigint, round_number: number, action: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "simulate_chances",
                    [props.duelist_id,
                props.duel_id,
                props.round_number,
                props.action],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_valid_packed_actions` system with the specified Account and calldata
        const get_valid_packed_actions = async (props: { account: Account, round_number: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_valid_packed_actions",
                    [props.round_number],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `pack_action_slots` system with the specified Account and calldata
        const pack_action_slots = async (props: { account: Account, slot1: number, slot2: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "pack_action_slots",
                    [props.slot1,
                props.slot2],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `unpack_action_slots` system with the specified Account and calldata
        const unpack_action_slots = async (props: { account: Account, packed: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "unpack_action_slots",
                    [props.packed],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, mint_duelist, update_duelist, create_challenge, reply_challenge, commit_action, reveal_action, get_pact, has_pact, can_join, calc_fee, simulate_chances, get_valid_packed_actions, pack_action_slots, unpack_action_slots
        };
    }

    // System definitions for `pistols-admin` contract
    function admin() {
        const contract_name = "admin";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "world",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_owner` system with the specified Account and calldata
        const set_owner = async (props: { account: Account, owner_address: bigint, granted: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_owner",
                    [props.owner_address,
                props.granted],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_treasury` system with the specified Account and calldata
        const set_treasury = async (props: { account: Account, treasury_address: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_treasury",
                    [props.treasury_address],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_paused` system with the specified Account and calldata
        const set_paused = async (props: { account: Account, paused: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_paused",
                    [props.paused],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `set_table` system with the specified Account and calldata
        const set_table = async (props: { account: Account, table_id: bigint, contract_address: bigint, description: bigint, fee_min: bigint, fee_pct: number, is_open: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "set_table",
                    [props.table_id,
                props.contract_address,
                props.description,
                props.fee_min,
                props.fee_pct,
                props.is_open],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `open_table` system with the specified Account and calldata
        const open_table = async (props: { account: Account, table_id: bigint, is_open: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "open_table",
                    [props.table_id,
                props.is_open],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_config` system with the specified Account and calldata
        const get_config = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_config",
                    [],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `get_table` system with the specified Account and calldata
        const get_table = async (props: { account: Account, table_id: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    contract_name,
                    "get_table",
                    [props.table_id],
                    "pistols"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, set_owner, set_treasury, set_paused, set_table, open_table, get_config, get_table
        };
    }

    return {
        minter: minter(),
        token_duelist: token_duelist(),
        lords_mock: lords_mock(),
        actions: actions(),
        admin: admin()
    };
}
